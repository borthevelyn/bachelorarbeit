module Translator.Main

open Translator.Types
open Translator.PathAnalyzer
open Translator.OpenCLWriter
open Translator.OpenMPWriter
open Translator.SingleThreadWriter
open Translator.CsvTable
open Averest.MiniC.IO
open Averest.MiniC.Types
open Averest.MiniC.DataflowProcessNetworks
open CommonWriter
open System.IO


let WriteCode mncs fileName =
    // generate program and dpn
    let errorStr = Some System.Console.Out
    let mncPrg = ParseMiniCFromString errorStr mncs
    let unleveledDpn = (MiniC2DPN mncPrg)[0]
    let (dpn, _, nodeLevels, _) = LevelizeDPN false false unleveledDpn
    //WriteDPN2Dotfile (fileName + "leveledDPN.gv") dpn None None None

    let preDefTypes =
        Array.concat [ (dpn.arrDecls |> Map.toArray)
                       mncPrg.SharedVariables ]
        |> Array.map (fun entry -> fst entry, constructBuffer (collapseArray (snd entry)) (fst entry) Standard)

    // analyze buffer types
    let bufferTypes: Map<string, Buffer> =
        buildBufferTypeLookup dpn (preDefTypes |> Map.ofArray) dpn.buffers

    // analyze vertex disjoint paths for deadlocks
    let _, paths = MinimumNumberOfVertexDisjointPathsDPN dpn

    // each path should fulfill this precondition - due to a bug in the vertex disjoint cover, this might
    // not be the case
    let precondition path =
        let levels =
            path
            |> List.map (fun n -> nodeLevels[n])
            |> List.sort
        
        levels = (seq {(levels |> List.min) .. (levels |> List.max) } |> List.ofSeq)

    // this function takes a path generated by the faulty vertex-disjoint cover and
    // returns a list of fixed paths. This relies on the assumption that the faulty path is actually a list of two or more
    // correct paths stuck together in a list. This function separates them
    let fixedPaths path : int list list =
        let leveledPath =
            path
            |> List.map (fun n -> nodeLevels[n], n)
        
        // marks the end of one path in a path by checking whether there is a follow up level node
        // in the set. If no follow-up node to `level` is contained, `level` marks the end of a path and
        // is used as a splitting node
        let endMarkers =
            leveledPath
            |> List.map fst
            |> List.filter (fun level -> not (leveledPath |> List.exists (fun (l, _) -> l = level + 1)))
        
        
        leveledPath
        |> List.groupBy (fun (level, _) -> 
            // group by the matching end marker
            endMarkers
            |> List.filter (fun marker -> marker >= level)
            |> List.min)
        |> List.map snd // collect the paths
        |> List.map (fun ls -> ls |> List.map snd) // only have the nodes, not the levels


    let newPaths = 
        paths
        |> Set.toList
        |> List.collect fixedPaths


    let pathBuffers: NamedPathBuffers list =
        newPaths
        |> List.map (fun path -> fst (calculatePathBuffers dpn path))
        |> List.indexed

    let pathDependencies: Set<PathDependency> =
        seq { 0 .. pathBuffers.Length - 1 }
        |> Set.ofSeq
        |> Set.map (calculatePathDependency dpn pathBuffers)
        |> Set.unionMany

    let deadlocks: Set<PathDeadlock> = calculateDeadlocks pathDependencies

    let resolvedPathsJoin = resolveDeadlocksPathJoin nodeLevels newPaths deadlocks |> Set.toList
    let resolvedPathsSplit = resolveDeadlocksPathSplit nodeLevels dpn newPaths deadlocks |> Set.toList

    let namedOneNodePaths =
        seq { 0 .. dpn.nodes.Length - 1 }
        |> List.ofSeq
        |> List.map (fun x ->
            let (outA, _, inA) = dpn.nodes[x]
            x, [x], (PathBuffers) (List.ofArray inA, List.ofArray outA))
    
    let namedResolvedPathsJoin =
        resolvedPathsJoin
        |> List.map (fun x -> (x, snd (calculatePathBuffers dpn x)))
        |> List.mapi (fun i (path, pb) -> i, path, pb)    
    
    let namedResolvedPathsSplit =
        resolvedPathsSplit
        |> List.map (fun x -> (x, snd (calculatePathBuffers dpn x)))
        |> List.mapi (fun i (path, pb) -> i, path, pb)

    let inputs = calculateKnownVariables dpn mncPrg

    let orderedNodePaths = calculateExecutionOrder namedOneNodePaths inputs
    let orderedResolvedPathsJoin = calculateExecutionOrder namedResolvedPathsJoin inputs
    let orderedResolvedPathsSplit = calculateExecutionOrder namedResolvedPathsSplit inputs

    // if the translator should produce output, uncomment the following lines
    //System.IO.File.WriteAllText("TestTranslations/SequentialCode.cpp", generateSingleThreadCode dpn bufferTypes orderedNodePaths mncPrg)
    //System.IO.File.WriteAllText("TestTranslations/OpenMP_Example_0.cpp", generateOpenMPCode dpn bufferTypes orderedNodePaths true mncPrg)
    //System.IO.File.WriteAllText("TestTranslations/OpenMP_Example_1.cpp", generateOpenMPCode dpn bufferTypes orderedResolvedPathsJoin true mncPrg)
    //System.IO.File.WriteAllText("TestTranslations/OpenMP_Example_2.cpp", generateOpenMPCode dpn bufferTypes orderedResolvedPathsSplit true mncPrg)
    //System.IO.File.WriteAllText("TestTranslations/OpenMP_Example_3.cpp", generateOpenMPCode dpn bufferTypes orderedResolvedPathsJoin false mncPrg)
    //System.IO.File.WriteAllText("TestTranslations/OpenCL_Example_0.cpp", generateCLCode dpn bufferTypes orderedNodePaths mncPrg)
    //System.IO.File.WriteAllText("TestTranslations/OpenCL_Example_1.cpp", generateCLCode dpn bufferTypes orderedResolvedPathsJoin mncPrg)

    createCsvTablesForBenchmarks
        orderedNodePaths
        orderedResolvedPathsJoin
        orderedResolvedPathsSplit
        namedOneNodePaths
        namedResolvedPathsJoin
        namedResolvedPathsSplit
        newPaths
        deadlocks
        dpn
        fileName


    (dpn, bufferTypes, orderedNodePaths, orderedResolvedPathsJoin, orderedResolvedPathsSplit, mncPrg)

//generate automatically cpp code from miniC programs
let mncPrgToCppPrg () =
    let pathMiniCPrograms = "MiniCPrograms1"
    let pathTranslatedPrograms = "TranslatedPrograms/"
    let fileEntries = Directory.GetFiles pathMiniCPrograms
    
    let writeFilePath tech fileName num =
        pathTranslatedPrograms
        + tech
        + fileName
        + "_"
        + num
        + ".cpp"
 
    let generateAllPrograms () = 
        System.Threading.Tasks.Parallel.ForEach(
            fileEntries,
            fun (filePath: string) ->
                if (not (File.Exists filePath)) then
                    File.Delete filePath

                let mncStr = File.ReadAllText filePath
                let fileName = (Path.GetFileName filePath).Split(".")[0]

                let (dpn, varTypes, orderedNodePaths, orderedResolvedPathsJoin, orderedResolvedPathsSplit, mncPrg) =
                    WriteCode mncStr fileName

                File.WriteAllText(
                    (writeFilePath "SingleThreaded_" fileName "0"),
                    generateSingleThreadCode dpn varTypes orderedNodePaths mncPrg
                )

                File.WriteAllText(
                    (writeFilePath "OpenCL_" fileName "0"),
                    generateCLCode dpn varTypes orderedNodePaths
                )

                File.WriteAllText(
                    (writeFilePath "OpenCL_" fileName "1"),
                    generateCLCode dpn varTypes orderedResolvedPathsJoin
                )
                // one-node paths
                File.WriteAllText(
                    (writeFilePath "OpenMP_" fileName "0"),
                    generateOpenMPCode dpn varTypes orderedNodePaths true mncPrg
                )
                // joined vertex-disjoint paths
                File.WriteAllText(
                    (writeFilePath "OpenMP_" fileName "1"),
                    generateOpenMPCode dpn varTypes orderedResolvedPathsJoin true mncPrg
                )
                // split vertex-disjoint paths
                File.WriteAllText(
                    (writeFilePath "OpenMP_" fileName "2"),
                    generateOpenMPCode dpn varTypes orderedResolvedPathsSplit true mncPrg
                )
                // single path 
                File.WriteAllText(
                    (writeFilePath "OpenMP_" fileName "3"),
                    generateOpenMPCode dpn varTypes orderedResolvedPathsJoin false mncPrg
                )
        )
        |> ignore
    
    // generate cpp code from MiniC for all programs in parallel
    generateAllPrograms ()
    // create csv tables for all programs 
    createCsvTableForAllPrograms ()